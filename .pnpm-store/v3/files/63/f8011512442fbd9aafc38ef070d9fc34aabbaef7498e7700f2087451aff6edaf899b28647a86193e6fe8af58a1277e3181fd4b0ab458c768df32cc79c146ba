{
  "version": 3,
  "sources": ["../src/log.ts", "../src/ansi.ts", "../src/error.ts", "../src/util.ts", "../src/level.ts", "../src/unicode.ts", "../src/widget.ts", "../src/inject.ts", "../src/hsv.ts", "../src/spinner.ts", "../src/progress.ts", "../src/index.ts"],
  "sourcesContent": ["import wrapAnsi from 'wrap-ansi';\nimport { writeSync } from 'node:fs';\nimport { ansi, colorize } from './ansi';\nimport { formatErrorObj } from './error';\nimport { level, LogLevel } from './level';\nimport { logSymbols } from './unicode';\nimport { PREFIX_LENGTH, STDOUT, stringify, wrapOptions } from './util';\nimport { clearWidgets, redrawWidgets } from './widget';\n\n/** Writes a log line with a custom prefix */\nexport function log(prefix: string, content: string) {\n  clearWidgets();\n\n  if (content === '') {\n    writeSync(STDOUT, '\\n');\n    return;\n  }\n\n  const wrapped = wrapAnsi(content, 90 - PREFIX_LENGTH, wrapOptions) //\n    .replace(/\\n\\s*/g, '\\n' + ' '.repeat(PREFIX_LENGTH));\n\n  writeSync(STDOUT, prefix + wrapped + '\\n');\n\n  redrawWidgets();\n}\n\n/** Writes a log line with a blue `info` prefix. */\nexport function info(...data: any[]) {\n  if (level >= LogLevel.Info) {\n    log(`${ansi.blueBright}${ansi.bold}info  ${ansi.reset}`, stringify(...data));\n  }\n}\n\n/** Writes a log line with a yellow `warn` prefix. */\nexport function warn(...data: any[]) {\n  if (level >= LogLevel.Warn) {\n    log(\n      `${ansi.yellowBright}${ansi.bold}warn  ${ansi.reset}`,\n      colorize(ansi.yellowBright, stringify(...data))\n    );\n  }\n}\n\n/**\n * Writes a log line with a red `error` prefix. Accepts an `Error` or `PrintableError` in addition\n * to standard text, in which case it will print the error in a pretty way.\n */\nexport function error(...data: any[]) {\n  if (level >= LogLevel.Error) {\n    log(\n      `${ansi.redBright}${ansi.bold}error ${ansi.reset}`,\n      data.length === 1 && data[0] instanceof Error\n        ? formatErrorObj(data[0])\n        : colorize(ansi.redBright, stringify(...data))\n    );\n  }\n}\n\n/** Writes a log line with a cyan `debug` prefix. These are not visible by default. */\nexport function debug(...data: any[]) {\n  if (level >= LogLevel.Debug) {\n    log(`${ansi.cyanBright}${ansi.bold}debug ${ansi.reset}`, stringify(...data));\n  }\n}\n\n/** Writes a log line in all green and with a checkmark prefix. */\nexport function success(...data: any[]) {\n  if (level >= LogLevel.Info) {\n    const str = stringify(...data);\n\n    clearWidgets();\n    if (str === '') {\n      writeSync(0, '\\n');\n    } else {\n      writeSync(\n        0,\n        wrapAnsi(\n          colorize(ansi.green + ansi.bold, logSymbols.success + ' ' + str),\n          90,\n          wrapOptions\n        ) + '\\n'\n      );\n    }\n    redrawWidgets();\n  }\n}\n\n/** Writes a log line in all red and with a cross prefix. */\nexport function fail(...data: any[]) {\n  if (level >= LogLevel.Info) {\n    const str = stringify(...data);\n\n    clearWidgets();\n    if (str === '') {\n      writeSync(0, '\\n');\n    } else {\n      writeSync(\n        0,\n        data.length === 1 && data[0] instanceof Error\n          ? formatErrorObj(data[0], true)\n          : wrapAnsi(\n              colorize(ansi.red + ansi.bold, logSymbols.error + ' ' + stringify(...data)),\n              90,\n              wrapOptions\n            ) + '\\n'\n      );\n    }\n    redrawWidgets();\n  }\n}\n\n/** Writes raw line of text, but will do nothing if the log level is set to `LogLevel.Silent` */\nexport function writeLine(data: string) {\n  if (level > LogLevel.Silent) {\n    clearWidgets();\n    writeSync(STDOUT, data + '\\n');\n    redrawWidgets();\n  }\n}\n", "import supportsColor from 'supports-color';\n\nexport const ansi = {\n  bold: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underlined: '\\x1b[4m',\n  blink: '\\x1b[5m',\n  reverse: '\\x1b[7m',\n  hidden: '\\x1b[8m',\n\n  reset: '\\x1b[0m',\n  resetBold: '\\x1b[21m',\n  resetDim: '\\x1b[22m',\n  resetUnderlined: '\\x1b[24m',\n  resetBlink: '\\x1b[25m',\n  resetReverse: '\\x1b[27m',\n  resetHidden: '\\x1b[28m',\n\n  black: '\\x1b[30m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n  blackBright: '\\x1b[90m',\n  redBright: '\\x1b[91m',\n  greenBright: '\\x1b[92m',\n  yellowBright: '\\x1b[93m',\n  blueBright: '\\x1b[94m',\n  magentaBright: '\\x1b[95m',\n  cyanBright: '\\x1b[96m',\n  whiteBright: '\\x1b[97m',\n  bgBlack: '\\x1b[40m',\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n  bgBlue: '\\x1b[44m',\n  bgMagenta: '\\x1b[45m',\n  bgCyan: '\\x1b[46m',\n  bgWhite: '\\x1b[47m',\n  bgBlackBright: '\\x1b[100m',\n  bgRedBright: '\\x1b[101m',\n  bgGreenBright: '\\x1b[102m',\n  bgYellowBright: '\\x1b[103m',\n  bgBlueBright: '\\x1b[104m',\n  bgMagentaBright: '\\x1b[105m',\n  bgCyanBright: '\\x1b[106m',\n  bgWhiteBright: '\\x1b[107m',\n\n  up(n: number) {\n    return n === 0 ? '' : n === 1 ? `\\x1b[A` : `\\x1b[${n}A`;\n  },\n  down(n: number) {\n    return n === 0 ? '' : n === 1 ? `\\x1b[B` : `\\x1b[${n}B`;\n  },\n  forward(n: number) {\n    return n === 0 ? '' : n === 1 ? `\\x1b[C` : `\\x1b[${n}C`;\n  },\n  backward(n: number) {\n    return n === 0 ? '' : n === 1 ? `\\x1b[D` : `\\x1b[${n}D`;\n  },\n\n  clearLine: '\\x1b[2K',\n\n  show: '\\x1b[?25h',\n  hide: '\\x1b[?25l',\n\n  rgb(r: number, g: number, b: number) {\n    return `\\x1b[38;2;${r};${g};${b}m`;\n  },\n  bgRgb(r: number, g: number, b: number) {\n    return `\\x1b[48;2;${r};${g};${b}m`;\n  },\n};\n\nif (!supportsColor.stdout) {\n  Object.keys(ansi).forEach(key => {\n    (ansi as any)[key] = typeof ansi[key as keyof typeof ansi] === 'function' ? () => '' : '';\n  });\n}\n\nexport function colorize(color: string, str: string) {\n  return color + str.replaceAll(ansi.reset, ansi.reset + color) + ansi.reset;\n}\n\nconst colorList = [\n  'bold',\n  'dim',\n  'underlined',\n  'blink',\n  'reverse',\n  'hidden',\n  'black',\n  'red',\n  'green',\n  'yellow',\n  'blue',\n  'magenta',\n  'cyan',\n  'white',\n  'blackBright',\n  'redBright',\n  'greenBright',\n  'yellowBright',\n  'blueBright',\n  'magentaBright',\n  'cyanBright',\n  'whiteBright',\n  'bgBlack',\n  'bgRed',\n  'bgGreen',\n  'bgYellow',\n  'bgBlue',\n  'bgMagenta',\n  'bgCyan',\n  'bgWhite',\n  'bgBlackBright',\n  'bgRedBright',\n  'bgGreenBright',\n  'bgYellowBright',\n  'bgBlueBright',\n  'bgMagentaBright',\n  'bgCyanBright',\n  'bgWhiteBright',\n] as const;\n\ninterface T1 {\n  /** Applies this color to a given string. */\n  fn(str: string): string;\n}\nexport type ColorObject = { [K in keyof T1 as typeof colorList[number]]: T1[K] } & {\n  /** Applies this RGB color to a given string. */\n  rgb(r: number, g: number, b: number, string: string): string;\n  /** Applies this RGB color to a given string. */\n  bgRgb(r: number, g: number, b: number, string: string): string;\n};\n\n/** Simpler alternative to `chalk`, provides methods that colorize strings. */\nexport const colors = {} as ColorObject;\n\nfor (const colorName of colorList) {\n  Object.defineProperty(colors, colorName, {\n    value(str: string) {\n      return colorize(ansi[colorName], str);\n    },\n  });\n}\n\ncolors.rgb = (r: number, g: number, b: number, string: string) =>\n  colorize(ansi.rgb(r, g, b), string);\ncolors.bgRgb = (r: number, g: number, b: number, string: string) =>\n  colorize(ansi.bgRgb(r, g, b), string);\n", "import path from 'node:path';\nimport wrapAnsi from 'wrap-ansi';\nimport { builtinModules } from 'node:module';\nimport { ansi } from './ansi';\nimport { PREFIX_LENGTH, wrapOptions } from './util';\n\n/**\n * A Printable Error is an error that defines some extra fields. `@paperdave/logger` handles these\n * objects within logs which allows customizing their appearance. It can be useful when building\n * CLIs to throw formatted error objects that instruct the user what they did wrong, without\n * printing a huge piece of text with a useless stack trace.\n *\n * @see {CLIError} an easy class to construct these objects.\n */\nexport interface PrintableError extends Error {\n  description: string;\n  hideStack?: boolean;\n  hideName?: boolean;\n}\n\nexport function isBuiltin(pathname: string): boolean {\n  return pathname.startsWith('node:') || builtinModules.includes(pathname);\n}\n\n/** Utility function we use internally for formatting the stack trace of an error. */\nexport function formatStackTrace(err: Error) {\n  if (!err.stack) {\n    return '';\n  }\n  const v8firstLine = `${err.name}${err.message ? ': ' + err.message : ''}\\n`;\n  const parsed = err.stack.startsWith(v8firstLine)\n    ? err.stack\n        .slice(v8firstLine.length)\n        .split('\\n')\n        .map(line => {\n          const match = /at (.*) \\((.*):(\\d+):(\\d+)\\)/.exec(line);\n          if (!match) {\n            return { method: '<unknown>', file: null, line: null, column: null };\n          }\n          return {\n            method: match[1],\n            file: match[2],\n            line: parseInt(match[3], 10),\n            column: parseInt(match[4], 10),\n            native: line.includes('[native code]'),\n          };\n        })\n    : err.stack.split('\\n').map(line => {\n        const at = line.indexOf('@');\n        const method = line.slice(0, at);\n        const file = line.slice(at + 1);\n        const fileSplit = /^(.*?):(\\d+):(\\d+)$/.exec(file);\n        return {\n          method: (['module code'].includes(method) ? '' : method) || '',\n          file: fileSplit ? fileSplit[1] : null,\n          line: fileSplit ? parseInt(fileSplit[2], 10) : null,\n          column: fileSplit ? parseInt(fileSplit[3], 10) : null,\n          native: file === '[native code]',\n        };\n      });\n\n  const firstNative = parsed.reverse().findIndex(line => !line.native);\n  if (firstNative !== -1) {\n    // remove the first native lines\n    parsed.splice(0, firstNative, {\n      native: true,\n      method: '',\n      column: null,\n      line: null,\n      file: null,\n    });\n  }\n  parsed.reverse();\n\n  return (\n    parsed\n      .map(({ method, file, line, column, native }) => {\n        const source = native\n          ? `[native code]`\n          : file\n          ? isBuiltin(file)\n            ? `(${ansi.magenta}${file}${ansi.reset}${ansi.blackBright})`\n            : [\n                '(',\n                ansi.cyan,\n                // Leave the first slash on linux.\n                process.platform === 'win32'\n                  ? path.dirname(file).replace(/^file:\\/\\/\\//g, '')\n                  : path.dirname(file).replace(/^file:\\/\\//g, ''),\n                path.sep,\n                ansi.green,\n                path.basename(file),\n                ansi.reset,\n                ':',\n                line + ':' + column,\n                ansi.blackBright,\n                ')',\n              ].join('')\n          : '<unknown>';\n\n        return `\\u200b  ${ansi.blackBright}at ${method === '' ? '' : `${method} `}${source}`;\n      })\n      .join('\\n') + ansi.reset\n  );\n}\n\n/** Formats the given error as a full log string. */\nexport function formatErrorObj(err: Error | PrintableError, boldFirstLine = false) {\n  const { name, message, description, hideStack, hideName, stack } = err as PrintableError;\n\n  return [\n    boldFirstLine ? ansi.red + ansi.bold : ansi.red,\n    hideName ? '' : (name ?? 'Error') + ': ',\n    message ?? 'Unknown error',\n    ansi.reset,\n    description ? '\\n' + wrapAnsi(description, 90 - PREFIX_LENGTH, wrapOptions) : '',\n    hideStack || !stack ? '' : '\\n' + formatStackTrace(err),\n    description || (!hideStack && stack) ? '\\n' : '',\n  ].join('');\n}\n\n/**\n * When this error is passed to `log.error`, it will be printed with a custom long-description. This\n * is useful to give users a better description on what the error actually is. Does not show a stack\n * trace by default.\n *\n * For example, in Purplet we throw this error if the `$DISCORD_BOT_TOKEN` environment variable is missing.\n *\n * ```ts\n * new CLIError(\n *   'Missing DISCORD_BOT_TOKEN environment variable!',\n *   dedent`\n *     Please create an ${chalk.cyan('.env')} file with the following contents:\n *\n *     ${chalk.cyanBright('DISCORD_BOT_TOKEN')}=${chalk.grey('<your bot token>')}\n *\n *     You can create or reset your bot token at ${devPortalLink}\n *   `\n * );\n * ```\n */\nexport class CLIError extends Error implements PrintableError {\n  constructor(public message: string, public description: string) {\n    super(message);\n    this.name = 'CLIError';\n  }\n\n  get hideStack() {\n    return true;\n  }\n\n  get hideName() {\n    return true;\n  }\n}\n", "import { inspect } from 'util';\n\n/**\n * In this package we use `writeSync(STDOUT, ...)` to write to the stdout instead of\n * `console.log(...)`, or `process.stdout.write(...)` since it is faster and the code will work\n * across node and bun.\n */\nexport const STDOUT = 1;\n\n/** Hardcoded magic number, all prefixes are 6 characters excluding colors, eg `info `. */\nexport const PREFIX_LENGTH = 6;\n\n/** For `ansi-wrap` */\nexport const wrapOptions = {\n  trim: false,\n  hard: true,\n};\n\n/** Converts non string objects into a string the way Node.js' console.log does it. */\nexport function stringify(...data: any[]) {\n  return data.map(obj => (typeof obj === 'string' ? obj : inspect(obj, false, 4, true))).join(' ');\n}\n\nexport type Timer = ReturnType<typeof setInterval>;\n\n/** A console color enum. */\nexport enum Color {\n  Black = 'black',\n  Red = 'red',\n  Green = 'green',\n  Yellow = 'yellow',\n  Blue = 'blue',\n  Magenta = 'magenta',\n  Cyan = 'cyan',\n  White = 'white',\n  BlackBright = 'blackBright',\n  RedBright = 'redBright',\n  GreenBright = 'greenBright',\n  YellowBright = 'yellowBright',\n  BlueBright = 'blueBright',\n  MagentaBright = 'magentaBright',\n  CyanBright = 'cyanBright',\n  WhiteBright = 'whiteBright',\n}\n", "/** Enum of log level names to their level ID. */\nexport enum LogLevel {\n  /** Print nothing. */\n  Silent = 0,\n  /** Print only errors. */\n  Error = 1,\n  /** Print warnings and errors. */\n  Warn = 2,\n  /** Print all non-debug, the default. */\n  Info = 3,\n  /** Print everything. Default is `process.env.DEBUG` is set to true. */\n  Debug = 4,\n}\n\n/** Either a LogLevel or a string key of the LogLevel. */\ntype SetLevelInput = LogLevel | Lowercase<keyof typeof LogLevel>;\n\n/** The log level. */\nexport let level =\n  typeof process !== 'undefined' && !!process.env.DEBUG ? LogLevel.Debug : LogLevel.Info;\n\n/** Sets the log level. Accepts a `LogLevel` enum or a string. */\nexport function setLevel(show: SetLevelInput) {\n  if (typeof show === 'number') {\n    level = show;\n  } else {\n    switch (show) {\n      case 'debug':\n        level = LogLevel.Debug;\n        break;\n      case 'info':\n        level = LogLevel.Info;\n        break;\n      case 'warn':\n        level = LogLevel.Warn;\n        break;\n      case 'error':\n        level = LogLevel.Error;\n        break;\n      case 'silent':\n        level = LogLevel.Silent;\n        break;\n    }\n  }\n}\n", "// Inlined from\n// https://github.com/sindresorhus/is-unicode-supported/blob/main/index.js\n\n/**\n * Boolean if the current environment supports unicode. Functions identically to the\n * `is-unicode-supported` package.\n */\nexport const isUnicodeSupported =\n  process.platform === 'win32'\n    ? Boolean(process.env.CI) ||\n      Boolean(process.env.WT_SESSION) || // Windows Terminal\n      process.env.ConEmuTask === '{cmd::Cmder}' || // ConEmu and cmder\n      process.env.TERM_PROGRAM === 'vscode' ||\n      process.env.TERM === 'xterm-256color' ||\n      process.env.TERM === 'alacritty' ||\n      process.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm'\n    : process.env.TERM !== 'linux';\n\n// Inlined without chalk from\n// https://github.com/sindresorhus/log-symbols/blob/main/index.js\n\n/**\n * Contains unicode symbols for various log symbols, falling to non-unicode characters if needed.\n * Does not have colors, unlike the `log-symbols` package this is based off of.\n */\nexport const logSymbols = isUnicodeSupported\n  ? {\n      error: '\u2716',\n      success: '\u2714',\n      info: '\u2139',\n      warning: '\u26A0',\n    }\n  : {\n      error: 'x',\n      success: '\u221A',\n      info: 'i',\n      warning: '\u203C',\n    };\n", "import { writeSync } from 'fs';\nimport { ansi } from './ansi';\nimport { fail, success } from './log';\nimport type { Timer } from './util';\nimport { STDOUT } from './util';\n\nconst widgets: LogWidget[] = [];\nlet widgetLineCount = 0;\nlet widgetTimer: Timer | undefined;\nlet widgetDrawingDisabled = false;\n\n/**\n * A Log Widget is a piece of log content that is held at the bottom of the console log, and can be\n * animated/dynamically updated. It is used to create spinners, progress bars, and other rich visuals.\n */\nexport abstract class LogWidget {\n  constructor() {\n    widgets.push(this);\n\n    if (!widgetTimer) {\n      widgetTimer = setInterval(redrawWidgets, 1000 / 60);\n      writeSync(STDOUT, ansi.hide);\n    }\n  }\n\n  /**\n   * Returns a string of what the widget looks like. Called 15 times per second to allow for smooth\n   * animation. The value passed to now is the result of `performance.now`.\n   */\n  protected abstract format(now: number): string;\n  /**\n   * The current FPS of the widget. If this is set to 0, the widget will not automatically update,\n   * and you must call `update`.\n   */\n  protected abstract fps: number;\n\n  /** Removes this widget from the log. */\n  protected remove(finalMessage?: string) {\n    const index = widgets.indexOf(this);\n    if (index >= 0) {\n      widgets.splice(index, 1);\n    }\n    clearWidgets();\n    if (finalMessage) {\n      writeSync(STDOUT, finalMessage + '\\n');\n    }\n    if (widgets.length === 0) {\n      clearInterval(widgetTimer);\n      widgetTimer = undefined;\n      writeSync(STDOUT, ansi.show);\n    } else {\n      redrawWidgets();\n    }\n  }\n\n  /** Forces a redraw to happen immediately. */\n  protected redraw() {\n    this.#nextUpdate = 0;\n    redrawWidgets();\n  }\n\n  #nextUpdate = 0;\n  #text = '';\n  #newlines = 0;\n\n  /** @internal */\n  private __internalUpdate(now: number) {\n    if (now > this.#nextUpdate) {\n      this.#nextUpdate = this.fps === 0 ? Infinity : now + 1000 / this.fps;\n      const text = this.format(now);\n      if (text !== this.#text) {\n        this.#text = text + '\\n';\n        this.#newlines = text.split('\\n').length;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /** @interal */\n  private __internalGetText() {\n    widgetLineCount += this.#newlines;\n    return this.#text;\n  }\n\n  /**\n   * Runs the given function without redrawing anything, then runs a redraws. This is used to batch\n   * some updates together without having to redraw the current widgets more than once per frame.\n   */\n  static batchRedraw(fn: () => void) {\n    widgetDrawingDisabled = true;\n    fn();\n    widgetDrawingDisabled = false;\n    redrawWidgets();\n  }\n\n  /** Remove this widget with a success message. */\n  success(message: string) {\n    LogWidget.batchRedraw(() => {\n      success(message);\n      this.remove();\n    });\n  }\n\n  /** Remove this widget with a failure message. */\n  fail(message: string | Error) {\n    LogWidget.batchRedraw(() => {\n      fail(message);\n      this.remove();\n    });\n  }\n}\n\nexport function clearWidgets() {\n  if (widgetLineCount) {\n    writeSync(\n      STDOUT,\n      ansi.clearLine + (ansi.up(1) + ansi.clearLine).repeat(widgetLineCount) + '\\r'\n    );\n    widgetLineCount = 0;\n  }\n}\n\nexport function redrawWidgets() {\n  if (!widgetTimer || widgetDrawingDisabled) {\n    return;\n  }\n\n  const now = performance.now();\n  const hasUpdate = widgets.filter(widget => widget['__internalUpdate'](now)).length > 0;\n\n  if (hasUpdate || widgetLineCount === 0) {\n    clearWidgets();\n    writeSync(STDOUT, widgets.map(widget => widget['__internalGetText']()).join(''));\n  }\n}\n", "import { debug, error, info, warn } from './log';\n\n/**\n * Injects the logger into `globalThis.console`, or whatever is given. Only fills the following\n * functions: `log`, `info`, `warn`, `error`, `debug`.\n *\n * For accessing some special functions, use the `log` object directly.\n */\nexport function injectLogger(obj = console) {\n  obj.log = info;\n  obj.info = info;\n  obj.warn = warn;\n  obj.error = error;\n  obj.debug = debug;\n  // TODO: Add the rest of the `console` functions, such as `time`\n}\n", "export function convertHSVtoRGB(h: number, s: number, v: number): [number, number, number] {\n  let r, g, b;\n  const i = Math.floor(h * 6);\n  const f = h * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n    default:\n      return [0, 0, 0];\n  }\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n", "import wrapAnsi from 'wrap-ansi';\nimport { ansi } from './ansi';\nimport { Color, wrapOptions } from './util';\nimport { LogWidget } from './widget';\n\nexport interface SpinnerOptions<Props extends Record<string, unknown>> {\n  /** Text displayed to the right of the spinner. */\n  text: string | ((props: Props) => string);\n  /** Color of the spinner. */\n  color?: Color | `${Color}` | false;\n  /** Sequence of frames for the spinner. */\n  frames?: string[];\n  /** Frames per second of the Spinner. */\n  fps?: number;\n  /** Properties to be passed to the `text` formatting function. */\n  props?: Props;\n}\n\nexport const defaultSpinnerOptions = {\n  text: 'Loading...',\n  color: Color.BlueBright,\n  frames: ['\u280B', '\u2819', '\u2839', '\u2838', '\u283C', '\u2834', '\u2826', '\u2827', '\u2807', '\u280F'],\n  fps: 12.5,\n};\n\nexport class Spinner<Props extends Record<string, unknown>> extends LogWidget {\n  #text: string | ((props: Props) => string);\n  #color: Color | `${Color}` | false;\n  #frames: string[];\n  #props: Props;\n  protected fps: number;\n\n  constructor(options: SpinnerOptions<Props>) {\n    super();\n    this.#text = options.text ?? defaultSpinnerOptions.text;\n    this.#color = options.color ?? defaultSpinnerOptions.color;\n    this.#frames = options.frames ?? defaultSpinnerOptions.frames;\n    this.fps = options.fps ?? defaultSpinnerOptions.fps;\n    this.#props = options.props ?? ({} as Props);\n  }\n\n  /** Text displayed to the right of the spinner. */\n  get text(): string {\n    return typeof this.#text === 'function' ? this.#text(this.#props) : this.#text;\n  }\n\n  set text(value: string | (() => string)) {\n    this.#text = value;\n    this.redraw();\n  }\n\n  /** Properties to be passed to `text` and `beforeText` formatting functions. */\n  set props(value: Partial<Props>) {\n    this.#props = {\n      ...this.#props,\n      ...value,\n    };\n    this.redraw();\n  }\n\n  get props(): Props {\n    return {\n      ...this.#props,\n    };\n  }\n\n  /**\n   * Updates the spinner by supplying either a new `message` string or a partial object of props to\n   * be used by the custom message function.\n   */\n  update(newProps: Partial<Props>): void;\n  update(newMessage: string): void;\n  update(newData: string | Partial<Props>) {\n    if (typeof newData === 'string') {\n      this.text = newData;\n    } else {\n      this.#props = { ...this.#props, ...newData };\n      this.redraw();\n    }\n  }\n\n  protected format(now: number): string {\n    const frame = Math.floor(now / (1000 / this.fps)) % this.#frames.length;\n\n    return (\n      (this.#color ? ansi[this.#color] + this.#frames[frame] + ansi.reset : this.#frames[frame]) +\n      ' ' +\n      wrapAnsi(this.text, 90 - 1 - this.#frames[frame].length, wrapOptions)\n    );\n  }\n\n  success(message?: string): void {\n    super.success(message ?? this.text);\n  }\n\n  fail(message?: string | Error): void {\n    super.fail(message ?? this.text);\n  }\n}\n\nexport interface WithSpinnerOptions<Props extends Record<string, unknown>, T>\n  extends SpinnerOptions<Props> {\n  successText?: string | ((result: T) => string);\n  failureText?: string | ((error: Error) => string);\n}\n\nexport async function withSpinner<Props extends Record<string, unknown>, T>(\n  fn: (spinner: Spinner<Props>) => Promise<T>,\n  opts: WithSpinnerOptions<Props, T>\n) {\n  const spinner = new Spinner(opts);\n\n  try {\n    const result = await fn(spinner);\n    spinner.success(\n      opts.successText\n        ? typeof opts.successText === 'function'\n          ? opts.successText(result)\n          : opts.successText\n        : opts.text\n        ? typeof opts.text === 'function'\n          ? opts.text(spinner.props)\n          : opts.text\n        : 'Completed'\n    );\n  } catch (error: any) {\n    spinner.fail(\n      typeof opts.failureText === 'function' ? opts.failureText(error) : opts.failureText ?? error\n    );\n    throw error;\n  }\n}\n", "import type { EmptyObject } from '@paperdave/utils';\nimport { ansi } from './ansi';\nimport { convertHSVtoRGB } from './hsv';\nimport { defaultSpinnerOptions } from './spinner';\nimport { isUnicodeSupported } from './unicode';\nimport type { Color } from './util';\nimport { LogWidget } from './widget';\n\nconst boxChars = [' ', '\u258F', '\u258E', '\u258D', '\u258C', '\u258B', '\u258A', '\u2589'];\nconst fullBox = '\u2588';\nconst asciiChars = {\n  start: '[',\n  end: ']',\n  empty: ' ',\n  fill: '=',\n};\n\n/**\n * This function is derived from an old program I wrote back in 2020 called `f` which did ffmpeg\n * handling. It is probably one of the coolest progress bars ever imagined. The original had the HSL\n * colors baked in, but this one doesn't do that.\n *\n * For those interested:\n * https://github.com/paperdave/f/blob/fcc418f11c7abe979ec01d90d5fdf7e50fb6ec25/src/render.ts.\n */\nfunction getUnicodeBar(progress: number, width: number) {\n  if (progress >= 1) {\n    return fullBox.repeat(width);\n  }\n  if (progress <= 0 || isNaN(progress)) {\n    return ' '.repeat(width);\n  }\n\n  const wholeWidth = Math.floor(progress * width);\n  const remainderWidth = (progress * width) % 1;\n  const partWidth = Math.floor(remainderWidth * 8);\n  let partChar = boxChars[partWidth];\n  if (width - wholeWidth - 1 < 0) {\n    partChar = '';\n  }\n\n  const fill = fullBox.repeat(wholeWidth);\n  const empty = ' '.repeat(width - wholeWidth - 1);\n\n  return `${fill}${partChar}${empty}`;\n}\n\n/** Get an ascii progress bar. Boring. */\nfunction getAsciiBar(progress: number, width: number) {\n  return [\n    asciiChars.start,\n    asciiChars.fill.repeat(Math.floor(progress * (width - 2))),\n    asciiChars.empty.repeat(width - Math.ceil(progress * (width - 2))),\n    asciiChars.end,\n  ].join('');\n}\n\n/** A Progress Bar Style. Ascii is forced in non-unicode terminals. */\nexport enum BarStyle {\n  Unicode = 'unicode',\n  Ascii = 'ascii',\n}\n\n/** Options to be passed to `new Progress` */\nexport interface ProgressOptions<Props extends Record<string, unknown> = EmptyObject> {\n  /** Text displayed to the right of the bar. */\n  text: string | ((props: ExtendedProps<Props>) => string);\n  /** Text displayed to the left of the bar, if specified. */\n  beforeText?: string | ((props: ExtendedProps<Props>) => string);\n  /** Properties to be passed to `text` and `beforeText` formatting functions. */\n  props?: Props;\n  /** Width of the progress bar itself. Default: 35. */\n  barWidth?: number;\n  /** Progress bar style, default `BarStyle.Unicode` */\n  barStyle?: BarStyle | `${BarStyle}`;\n  /** Spinner settings. Set to `null` to disable the spinner. */\n  spinner?: Partial<BarSpinnerOptions> | null;\n  /** Starting value. Default: 0. */\n  value?: number;\n  /** Ending value. Default: 100. */\n  total?: number;\n}\n\nexport interface BarSpinnerOptions {\n  /** Frames per second of the Spinner. */\n  fps: number;\n  /** Sequence of frames for the spinner. */\n  frames: string[];\n  /** Color of the spinner. If set to `match` it will match the bar. */\n  color: Color | `${Color}` | 'match';\n}\n\nconst defaultOptions = {\n  beforeText: '',\n  barWidth: 35,\n  barColor: 'rgb',\n  barStyle: BarStyle.Unicode,\n  spinner: {\n    ...defaultSpinnerOptions,\n    color: 'match',\n  },\n  value: 0,\n  total: 100,\n} as const;\n\ntype ExtendedProps<T> = T & {\n  value: number;\n  total: number;\n  /** Number 0-1, inclusive. */\n  progress: number;\n};\n\nexport class Progress<Props extends Record<string, unknown>> extends LogWidget {\n  #text: string | ((props: ExtendedProps<Props>) => string);\n  #beforeText: string | ((props: ExtendedProps<Props>) => string);\n  #barWidth: number;\n  #barStyle: NonNullable<ProgressOptions['barStyle']>;\n  #spinnerColor: NonNullable<BarSpinnerOptions['color']>;\n  #spinnerFrames?: string[];\n  #props: Props;\n  #spinnerFPS: number;\n  #value: number;\n  #total: number;\n  protected fps: number;\n\n  constructor(options: ProgressOptions<Props>) {\n    super();\n\n    this.#text = options.text;\n    this.#beforeText = options.beforeText ?? defaultOptions.beforeText;\n    this.#barWidth = options.barWidth ?? defaultOptions.barWidth;\n    this.#barStyle = options.barStyle ?? defaultOptions.barStyle;\n    this.#props = options.props ?? ({} as Props);\n    this.#value = options.value ?? defaultOptions.value;\n    this.#total = options.total ?? defaultOptions.total;\n\n    // Undefined will trigger the \"no spinner\"\n    // eslint-disable-next-line eqeqeq\n    if (options.spinner !== null) {\n      this.fps = 15;\n      this.#spinnerFPS = options.spinner?.fps ?? defaultOptions.spinner.fps;\n      this.#spinnerFrames = options.spinner?.frames ?? defaultOptions.spinner.frames;\n      this.#spinnerColor = options.spinner?.color ?? defaultOptions.spinner.color;\n    } else {\n      this.fps = 0;\n      this.#spinnerFPS = defaultOptions.spinner.fps;\n      this.#spinnerFrames = undefined;\n      this.#spinnerColor = defaultOptions.spinner.color;\n    }\n  }\n\n  /** Properties to be passed to `text` and `beforeText` formatting functions. */\n  set props(value: Partial<Props>) {\n    this.#props = {\n      ...this.#props,\n      ...value,\n    };\n    this.redraw();\n  }\n\n  get props(): ExtendedProps<Props> {\n    return {\n      ...this.#props,\n      value: this.#value,\n      total: this.#total,\n      progress: this.#total === 0 ? 1 : this.#value / this.#total,\n    };\n  }\n\n  /** Text displayed to the right of the bar. */\n  get text(): string {\n    return typeof this.#text === 'function' ? this.#text(this.props) : this.#text;\n  }\n\n  set text(value: string | (() => string)) {\n    this.#text = value;\n    this.redraw();\n  }\n\n  /** Text displayed to the left of the bar, if specified. */\n  get beforeText(): string {\n    return typeof this.#beforeText === 'function' ? this.#beforeText(this.props) : this.#beforeText;\n  }\n\n  set beforeText(value: string | (() => string)) {\n    this.#beforeText = value;\n    this.redraw();\n  }\n  /** Current value of progress bar. */\n  get value() {\n    return this.value;\n  }\n\n  set value(value: number) {\n    this.#value = value;\n    this.redraw();\n  }\n\n  /** Total value of progress bar. When value === total, the bar is full. */\n  get total() {\n    return this.value;\n  }\n\n  set total(value: number) {\n    this.#total = value;\n    this.redraw();\n  }\n\n  /** Updates the progress bar with a new value and props. */\n  update(value: number, props?: Partial<Props>) {\n    this.#value = value;\n    if (props) {\n      this.#props = {\n        ...this.props,\n        ...props,\n      };\n    }\n    this.redraw();\n  }\n\n  protected format(now: number): string {\n    const progress = this.#total === 0 ? 1 : this.#value / this.#total;\n\n    const hue = Math.min(Math.max(progress, 0), 1) / 3;\n    const barColor =\n      ansi.rgb(...convertHSVtoRGB(hue, 0.8, 1)) + //\n      ansi.bgRgb(...convertHSVtoRGB(hue, 0.8, 0.5));\n\n    let spinner;\n    if (this.#spinnerFrames) {\n      const frame = Math.floor(now / (1000 / this.#spinnerFPS)) % this.#spinnerFrames.length;\n      spinner = this.#spinnerColor\n        ? (this.#spinnerColor === 'match'\n            ? ansi.rgb(...convertHSVtoRGB(hue, 0.8, 1))\n            : ansi[this.#spinnerColor]) +\n          this.#spinnerFrames[frame] +\n          ansi.reset\n        : this.#spinnerFrames[frame];\n    }\n\n    const getBar = isUnicodeSupported && this.#barStyle === 'unicode' ? getUnicodeBar : getAsciiBar;\n\n    const beforeText = this.beforeText;\n\n    return [\n      spinner ? spinner + ' ' : '',\n      beforeText ? beforeText + ' ' : '',\n      barColor,\n      getBar(progress, this.#barWidth),\n      ansi.reset,\n      ' ',\n      this.text,\n    ]\n      .filter(Boolean)\n      .join('');\n  }\n\n  success(message?: string): void {\n    super.success(message ?? this.text);\n  }\n\n  fail(message?: string | Error): void {\n    super.fail(message ?? this.text);\n  }\n}\n\nexport interface WithProgressOptions<Props extends Record<string, unknown>, T>\n  extends ProgressOptions<Props> {\n  /** Message to print on success. If a function, the result is passed. */\n  successText?: string | ((result: T) => string);\n  /** Message to print on fail. If a function, the error is passed. */\n  failureText?: string | ((error: Error) => string);\n}\n\nexport async function withProgress<Props extends Record<string, unknown>, T>(\n  fn: (bar: Progress<Props>) => Promise<T>,\n  opts: WithProgressOptions<Props, T>\n) {\n  const bar = new Progress(opts);\n\n  try {\n    const result = await fn(bar);\n    bar.success(\n      opts.successText\n        ? typeof opts.successText === 'function'\n          ? opts.successText(result)\n          : opts.successText\n        : opts.text\n        ? typeof opts.text === 'function'\n          ? opts.text(bar.props)\n          : opts.text\n        : 'Completed'\n    );\n  } catch (error: any) {\n    bar.fail(\n      typeof opts.failureText === 'function' ? opts.failureText(error) : opts.failureText ?? error\n    );\n    throw error;\n  }\n}\n", "import * as log from './log';\n\nexport { colors } from './ansi';\nexport { CLIError, type PrintableError } from './error';\nexport { injectLogger } from './inject';\nexport { LogLevel, setLevel } from './level';\nexport * from './log';\nexport {\n  BarStyle,\n  Progress,\n  withProgress,\n  type BarSpinnerOptions,\n  type ProgressOptions,\n  type WithProgressOptions,\n} from './progress';\nexport { Spinner, withSpinner, type SpinnerOptions } from './spinner';\nexport { isUnicodeSupported, logSymbols } from './unicode';\nexport { LogWidget } from './widget';\nexport default log;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;ACDA;AAEO,IAAM,OAAO;AAAA,EAClB,MAAM;AAAA,EACN,KAAK;AAAA,EACL,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AAAA,EAER,OAAO;AAAA,EACP,WAAW;AAAA,EACX,UAAU;AAAA,EACV,iBAAiB;AAAA,EACjB,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,aAAa;AAAA,EAEb,OAAO;AAAA,EACP,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM;AAAA,EACN,OAAO;AAAA,EACP,aAAa;AAAA,EACb,WAAW;AAAA,EACX,aAAa;AAAA,EACb,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,SAAS;AAAA,EACT,OAAO;AAAA,EACP,SAAS;AAAA,EACT,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,eAAe;AAAA,EACf,aAAa;AAAA,EACb,eAAe;AAAA,EACf,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,iBAAiB;AAAA,EACjB,cAAc;AAAA,EACd,eAAe;AAAA,EAEf,GAAG,GAAW;AACZ,WAAO,MAAM,IAAI,KAAK,MAAM,IAAI,WAAW,QAAQ;AAAA,EACrD;AAAA,EACA,KAAK,GAAW;AACd,WAAO,MAAM,IAAI,KAAK,MAAM,IAAI,WAAW,QAAQ;AAAA,EACrD;AAAA,EACA,QAAQ,GAAW;AACjB,WAAO,MAAM,IAAI,KAAK,MAAM,IAAI,WAAW,QAAQ;AAAA,EACrD;AAAA,EACA,SAAS,GAAW;AAClB,WAAO,MAAM,IAAI,KAAK,MAAM,IAAI,WAAW,QAAQ;AAAA,EACrD;AAAA,EAEA,WAAW;AAAA,EAEX,MAAM;AAAA,EACN,MAAM;AAAA,EAEN,IAAI,GAAW,GAAW,GAAW;AACnC,WAAO,aAAa,KAAK,KAAK;AAAA,EAChC;AAAA,EACA,MAAM,GAAW,GAAW,GAAW;AACrC,WAAO,aAAa,KAAK,KAAK;AAAA,EAChC;AACF;AAEA,IAAI,CAAC,cAAc,QAAQ;AACzB,SAAO,KAAK,IAAI,EAAE,QAAQ,SAAO;AAC/B,IAAC,KAAa,OAAO,OAAO,KAAK,SAA8B,aAAa,MAAM,KAAK;AAAA,EACzF,CAAC;AACH;AAEO,kBAAkB,OAAe,KAAa;AACnD,SAAO,QAAQ,IAAI,WAAW,KAAK,OAAO,KAAK,QAAQ,KAAK,IAAI,KAAK;AACvE;AAEA,IAAM,YAAY;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAcO,IAAM,SAAS,CAAC;AAEvB,WAAW,aAAa,WAAW;AACjC,SAAO,eAAe,QAAQ,WAAW;AAAA,IACvC,MAAM,KAAa;AACjB,aAAO,SAAS,KAAK,YAAY,GAAG;AAAA,IACtC;AAAA,EACF,CAAC;AACH;AAEA,OAAO,MAAM,CAAC,GAAW,GAAW,GAAW,WAC7C,SAAS,KAAK,IAAI,GAAG,GAAG,CAAC,GAAG,MAAM;AACpC,OAAO,QAAQ,CAAC,GAAW,GAAW,GAAW,WAC/C,SAAS,KAAK,MAAM,GAAG,GAAG,CAAC,GAAG,MAAM;;;ACzJtC;AACA;AACA;;;ACFA;AAOO,IAAM,SAAS;AAGf,IAAM,gBAAgB;AAGtB,IAAM,cAAc;AAAA,EACzB,MAAM;AAAA,EACN,MAAM;AACR;AAGO,sBAAsB,MAAa;AACxC,SAAO,KAAK,IAAI,SAAQ,OAAO,QAAQ,WAAW,MAAM,QAAQ,KAAK,OAAO,GAAG,IAAI,CAAE,EAAE,KAAK,GAAG;AACjG;;;ADDO,mBAAmB,UAA2B;AACnD,SAAO,SAAS,WAAW,OAAO,KAAK,eAAe,SAAS,QAAQ;AACzE;AAGO,0BAA0B,KAAY;AAC3C,MAAI,CAAC,IAAI,OAAO;AACd,WAAO;AAAA,EACT;AACA,QAAM,cAAc,GAAG,IAAI,OAAO,IAAI,UAAU,OAAO,IAAI,UAAU;AAAA;AACrE,QAAM,SAAS,IAAI,MAAM,WAAW,WAAW,IAC3C,IAAI,MACD,MAAM,YAAY,MAAM,EACxB,MAAM,IAAI,EACV,IAAI,UAAQ;AACX,UAAM,QAAQ,+BAA+B,KAAK,IAAI;AACtD,QAAI,CAAC,OAAO;AACV,aAAO,EAAE,QAAQ,aAAa,MAAM,MAAM,MAAM,MAAM,QAAQ,KAAK;AAAA,IACrE;AACA,WAAO;AAAA,MACL,QAAQ,MAAM;AAAA,MACd,MAAM,MAAM;AAAA,MACZ,MAAM,SAAS,MAAM,IAAI,EAAE;AAAA,MAC3B,QAAQ,SAAS,MAAM,IAAI,EAAE;AAAA,MAC7B,QAAQ,KAAK,SAAS,eAAe;AAAA,IACvC;AAAA,EACF,CAAC,IACH,IAAI,MAAM,MAAM,IAAI,EAAE,IAAI,UAAQ;AAChC,UAAM,KAAK,KAAK,QAAQ,GAAG;AAC3B,UAAM,SAAS,KAAK,MAAM,GAAG,EAAE;AAC/B,UAAM,OAAO,KAAK,MAAM,KAAK,CAAC;AAC9B,UAAM,YAAY,sBAAsB,KAAK,IAAI;AACjD,WAAO;AAAA,MACL,QAAS,EAAC,aAAa,EAAE,SAAS,MAAM,IAAI,KAAK,WAAW;AAAA,MAC5D,MAAM,YAAY,UAAU,KAAK;AAAA,MACjC,MAAM,YAAY,SAAS,UAAU,IAAI,EAAE,IAAI;AAAA,MAC/C,QAAQ,YAAY,SAAS,UAAU,IAAI,EAAE,IAAI;AAAA,MACjD,QAAQ,SAAS;AAAA,IACnB;AAAA,EACF,CAAC;AAEL,QAAM,cAAc,OAAO,QAAQ,EAAE,UAAU,UAAQ,CAAC,KAAK,MAAM;AACnE,MAAI,gBAAgB,IAAI;AAEtB,WAAO,OAAO,GAAG,aAAa;AAAA,MAC5B,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AACA,SAAO,QAAQ;AAEf,SACE,OACG,IAAI,CAAC,EAAE,QAAQ,MAAM,MAAM,QAAQ,aAAa;AAC/C,UAAM,SAAS,SACX,kBACA,OACA,UAAU,IAAI,IACZ,IAAI,KAAK,UAAU,OAAO,KAAK,QAAQ,KAAK,iBAC5C;AAAA,MACE;AAAA,MACA,KAAK;AAAA,MAEL,QAAQ,aAAa,UACjB,KAAK,QAAQ,IAAI,EAAE,QAAQ,iBAAiB,EAAE,IAC9C,KAAK,QAAQ,IAAI,EAAE,QAAQ,eAAe,EAAE;AAAA,MAChD,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,SAAS,IAAI;AAAA,MAClB,KAAK;AAAA,MACL;AAAA,MACA,OAAO,MAAM;AAAA,MACb,KAAK;AAAA,MACL;AAAA,IACF,EAAE,KAAK,EAAE,IACX;AAEJ,WAAO,WAAW,KAAK,iBAAiB,WAAW,KAAK,KAAK,GAAG,YAAY;AAAA,EAC9E,CAAC,EACA,KAAK,IAAI,IAAI,KAAK;AAEzB;AAGO,wBAAwB,KAA6B,gBAAgB,OAAO;AACjF,QAAM,EAAE,MAAM,SAAS,aAAa,WAAW,UAAU,UAAU;AAEnE,SAAO;AAAA,IACL,gBAAgB,KAAK,MAAM,KAAK,OAAO,KAAK;AAAA,IAC5C,WAAW,KAAM,SAAQ,WAAW;AAAA,IACpC,WAAW;AAAA,IACX,KAAK;AAAA,IACL,cAAc,OAAO,SAAS,aAAa,KAAK,eAAe,WAAW,IAAI;AAAA,IAC9E,aAAa,CAAC,QAAQ,KAAK,OAAO,iBAAiB,GAAG;AAAA,IACtD,eAAgB,CAAC,aAAa,QAAS,OAAO;AAAA,EAChD,EAAE,KAAK,EAAE;AACX;AAsBO,IAAM,WAAN,cAAuB,MAAgC;AAAA,EAC5D,YAAmB,SAAwB,aAAqB;AAC9D,UAAM,OAAO;AADI;AAAwB;AAEzC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,IAAI,YAAY;AACd,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,WAAW;AACb,WAAO;AAAA,EACT;AACF;;;AEzJO,IAAK,WAAL,kBAAK,cAAL;AAEL,kCAAS,KAAT;AAEA,iCAAQ,KAAR;AAEA,gCAAO,KAAP;AAEA,gCAAO,KAAP;AAEA,iCAAQ,KAAR;AAVU;AAAA;AAiBL,IAAI,QACT,OAAO,YAAY,eAAe,CAAC,CAAC,QAAQ,IAAI,QAAQ,gBAAiB;AAGpE,kBAAkB,MAAqB;AAC5C,MAAI,OAAO,SAAS,UAAU;AAC5B,YAAQ;AAAA,EACV,OAAO;AACL,YAAQ;AAAA,WACD;AACH,gBAAQ;AACR;AAAA,WACG;AACH,gBAAQ;AACR;AAAA,WACG;AACH,gBAAQ;AACR;AAAA,WACG;AACH,gBAAQ;AACR;AAAA,WACG;AACH,gBAAQ;AACR;AAAA;AAAA,EAEN;AACF;;;ACrCO,IAAM,qBACX,QAAQ,aAAa,UACjB,QAAQ,QAAQ,IAAI,EAAE,KACtB,QAAQ,QAAQ,IAAI,UAAU,KAC9B,QAAQ,IAAI,eAAe,kBAC3B,QAAQ,IAAI,iBAAiB,YAC7B,QAAQ,IAAI,SAAS,oBACrB,QAAQ,IAAI,SAAS,eACrB,QAAQ,IAAI,sBAAsB,uBAClC,QAAQ,IAAI,SAAS;AASpB,IAAM,aAAa,qBACtB;AAAA,EACE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,SAAS;AACX,IACA;AAAA,EACE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,SAAS;AACX;;;ACrCJ;AAMA,IAAM,UAAuB,CAAC;AAC9B,IAAI,kBAAkB;AACtB,IAAI;AACJ,IAAI,wBAAwB;AAT5B;AAeO,IAAe,aAAf,MAAyB;AAAA,EAC9B,cAAc;AA6Cd,oCAAc;AACd,8BAAQ;AACR,kCAAY;AA9CV,YAAQ,KAAK,IAAI;AAEjB,QAAI,CAAC,aAAa;AAChB,oBAAc,YAAY,eAAe,MAAO,EAAE;AAClD,gBAAU,QAAQ,KAAK,IAAI;AAAA,IAC7B;AAAA,EACF;AAAA,EAcA,AAAU,OAAO,cAAuB;AACtC,UAAM,QAAQ,QAAQ,QAAQ,IAAI;AAClC,QAAI,SAAS,GAAG;AACd,cAAQ,OAAO,OAAO,CAAC;AAAA,IACzB;AACA,iBAAa;AACb,QAAI,cAAc;AAChB,gBAAU,QAAQ,eAAe,IAAI;AAAA,IACvC;AACA,QAAI,QAAQ,WAAW,GAAG;AACxB,oBAAc,WAAW;AACzB,oBAAc;AACd,gBAAU,QAAQ,KAAK,IAAI;AAAA,IAC7B,OAAO;AACL,oBAAc;AAAA,IAChB;AAAA,EACF;AAAA,EAGA,AAAU,SAAS;AACjB,uBAAK,aAAc;AACnB,kBAAc;AAAA,EAChB;AAAA,EAOA,AAAQ,iBAAiB,KAAa;AACpC,QAAI,MAAM,mBAAK,cAAa;AAC1B,yBAAK,aAAc,KAAK,QAAQ,IAAI,WAAW,MAAM,MAAO,KAAK;AACjE,YAAM,OAAO,KAAK,OAAO,GAAG;AAC5B,UAAI,SAAS,mBAAK,QAAO;AACvB,2BAAK,OAAQ,OAAO;AACpB,2BAAK,WAAY,KAAK,MAAM,IAAI,EAAE;AAAA,MACpC;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAGA,AAAQ,oBAAoB;AAC1B,uBAAmB,mBAAK;AACxB,WAAO,mBAAK;AAAA,EACd;AAAA,EAMA,OAAO,YAAY,IAAgB;AACjC,4BAAwB;AACxB,OAAG;AACH,4BAAwB;AACxB,kBAAc;AAAA,EAChB;AAAA,EAGA,QAAQ,SAAiB;AACvB,eAAU,YAAY,MAAM;AAC1B,cAAQ,OAAO;AACf,WAAK,OAAO;AAAA,IACd,CAAC;AAAA,EACH;AAAA,EAGA,KAAK,SAAyB;AAC5B,eAAU,YAAY,MAAM;AAC1B,WAAK,OAAO;AACZ,WAAK,OAAO;AAAA,IACd,CAAC;AAAA,EACH;AACF;AAhGO,IAAe,YAAf;AA8CL;AACA;AACA;AAkDK,wBAAwB;AAC7B,MAAI,iBAAiB;AACnB,cACE,QACA,KAAK,YAAa,MAAK,GAAG,CAAC,IAAI,KAAK,WAAW,OAAO,eAAe,IAAI,IAC3E;AACA,sBAAkB;AAAA,EACpB;AACF;AAEO,yBAAyB;AAC9B,MAAI,CAAC,eAAe,uBAAuB;AACzC;AAAA,EACF;AAEA,QAAM,MAAM,YAAY,IAAI;AAC5B,QAAM,YAAY,QAAQ,OAAO,YAAU,OAAO,oBAAoB,GAAG,CAAC,EAAE,SAAS;AAErF,MAAI,aAAa,oBAAoB,GAAG;AACtC,iBAAa;AACb,cAAU,QAAQ,QAAQ,IAAI,YAAU,OAAO,qBAAqB,CAAC,EAAE,KAAK,EAAE,CAAC;AAAA,EACjF;AACF;;;AN7HO,aAAa,QAAgB,SAAiB;AACnD,eAAa;AAEb,MAAI,YAAY,IAAI;AAClB,eAAU,QAAQ,IAAI;AACtB;AAAA,EACF;AAEA,QAAM,UAAU,UAAS,SAAS,KAAK,eAAe,WAAW,EAC9D,QAAQ,UAAU,OAAO,IAAI,OAAO,aAAa,CAAC;AAErD,aAAU,QAAQ,SAAS,UAAU,IAAI;AAEzC,gBAAc;AAChB;AAGO,iBAAiB,MAAa;AACnC,MAAI,SAAS,cAAe;AAC1B,QAAI,GAAG,KAAK,aAAa,KAAK,aAAa,KAAK,SAAS,UAAU,GAAG,IAAI,CAAC;AAAA,EAC7E;AACF;AAGO,iBAAiB,MAAa;AACnC,MAAI,SAAS,cAAe;AAC1B,QACE,GAAG,KAAK,eAAe,KAAK,aAAa,KAAK,SAC9C,SAAS,KAAK,cAAc,UAAU,GAAG,IAAI,CAAC,CAChD;AAAA,EACF;AACF;AAMO,kBAAkB,MAAa;AACpC,MAAI,SAAS,eAAgB;AAC3B,QACE,GAAG,KAAK,YAAY,KAAK,aAAa,KAAK,SAC3C,KAAK,WAAW,KAAK,KAAK,cAAc,QACpC,eAAe,KAAK,EAAE,IACtB,SAAS,KAAK,WAAW,UAAU,GAAG,IAAI,CAAC,CACjD;AAAA,EACF;AACF;AAGO,kBAAkB,MAAa;AACpC,MAAI,SAAS,eAAgB;AAC3B,QAAI,GAAG,KAAK,aAAa,KAAK,aAAa,KAAK,SAAS,UAAU,GAAG,IAAI,CAAC;AAAA,EAC7E;AACF;AAGO,oBAAoB,MAAa;AACtC,MAAI,SAAS,cAAe;AAC1B,UAAM,MAAM,UAAU,GAAG,IAAI;AAE7B,iBAAa;AACb,QAAI,QAAQ,IAAI;AACd,iBAAU,GAAG,IAAI;AAAA,IACnB,OAAO;AACL,iBACE,GACA,UACE,SAAS,KAAK,QAAQ,KAAK,MAAM,WAAW,UAAU,MAAM,GAAG,GAC/D,IACA,WACF,IAAI,IACN;AAAA,IACF;AACA,kBAAc;AAAA,EAChB;AACF;AAGO,iBAAiB,MAAa;AACnC,MAAI,SAAS,cAAe;AAC1B,UAAM,MAAM,UAAU,GAAG,IAAI;AAE7B,iBAAa;AACb,QAAI,QAAQ,IAAI;AACd,iBAAU,GAAG,IAAI;AAAA,IACnB,OAAO;AACL,iBACE,GACA,KAAK,WAAW,KAAK,KAAK,cAAc,QACpC,eAAe,KAAK,IAAI,IAAI,IAC5B,UACE,SAAS,KAAK,MAAM,KAAK,MAAM,WAAW,QAAQ,MAAM,UAAU,GAAG,IAAI,CAAC,GAC1E,IACA,WACF,IAAI,IACV;AAAA,IACF;AACA,kBAAc;AAAA,EAChB;AACF;AAGO,mBAAmB,MAAc;AACtC,MAAI,QAAQ,gBAAiB;AAC3B,iBAAa;AACb,eAAU,QAAQ,OAAO,IAAI;AAC7B,kBAAc;AAAA,EAChB;AACF;;;AO9GO,sBAAsB,MAAM,SAAS;AAC1C,MAAI,MAAM;AACV,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,QAAQ;AAEd;;;ACfO,yBAAyB,GAAW,GAAW,GAAqC;AACzF,MAAI,GAAG,GAAG;AACV,QAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AAC1B,QAAM,IAAI,IAAI,IAAI;AAClB,QAAM,IAAI,IAAK,KAAI;AACnB,QAAM,IAAI,IAAK,KAAI,IAAI;AACvB,QAAM,IAAI,IAAK,KAAK,KAAI,KAAK;AAC7B,UAAQ,IAAI;AAAA,SACL;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA,SACG;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA,SACG;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA,SACG;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA,SACG;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA,SACG;AACH,MAAC,IAAI,GAAK,IAAI,GAAK,IAAI;AACvB;AAAA;AAEA,aAAO,CAAC,GAAG,GAAG,CAAC;AAAA;AAEnB,SAAO,CAAC,KAAK,MAAM,IAAI,GAAG,GAAG,KAAK,MAAM,IAAI,GAAG,GAAG,KAAK,MAAM,IAAI,GAAG,CAAC;AACvE;;;AC9BA;AAkBO,IAAM,wBAAwB;AAAA,EACnC,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ,CAAC,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,QAAG;AAAA,EACzD,KAAK;AACP;AAvBA;AAyBO,IAAM,UAAN,cAA6D,UAAU;AAAA,EAO5E,YAAY,SAAgC;AAC1C,UAAM;AAPR;AACA;AACA;AACA;AACA,wBAAU;AAIR,uBAAK,QAAQ,QAAQ,QAAQ,sBAAsB;AACnD,uBAAK,QAAS,QAAQ,SAAS,sBAAsB;AACrD,uBAAK,SAAU,QAAQ,UAAU,sBAAsB;AACvD,SAAK,MAAM,QAAQ,OAAO,sBAAsB;AAChD,uBAAK,QAAS,QAAQ,SAAU,CAAC;AAAA,EACnC;AAAA,EAGA,IAAI,OAAe;AACjB,WAAO,OAAO,mBAAK,YAAU,aAAa,mBAAK,QAAL,WAAW,mBAAK,WAAU,mBAAK;AAAA,EAC3E;AAAA,EAEA,IAAI,KAAK,OAAgC;AACvC,uBAAK,QAAQ;AACb,SAAK,OAAO;AAAA,EACd;AAAA,EAGA,IAAI,MAAM,OAAuB;AAC/B,uBAAK,QAAS;AAAA,MACZ,GAAG,mBAAK;AAAA,MACR,GAAG;AAAA,IACL;AACA,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,IAAI,QAAe;AACjB,WAAO;AAAA,MACL,GAAG,mBAAK;AAAA,IACV;AAAA,EACF;AAAA,EAQA,OAAO,SAAkC;AACvC,QAAI,OAAO,YAAY,UAAU;AAC/B,WAAK,OAAO;AAAA,IACd,OAAO;AACL,yBAAK,QAAS,EAAE,GAAG,mBAAK,SAAQ,GAAG,QAAQ;AAC3C,WAAK,OAAO;AAAA,IACd;AAAA,EACF;AAAA,EAEA,AAAU,OAAO,KAAqB;AACpC,UAAM,QAAQ,KAAK,MAAM,MAAO,OAAO,KAAK,IAAI,IAAI,mBAAK,SAAQ;AAEjE,WACG,oBAAK,UAAS,KAAK,mBAAK,WAAU,mBAAK,SAAQ,SAAS,KAAK,QAAQ,mBAAK,SAAQ,UACnF,MACA,UAAS,KAAK,MAAM,KAAK,IAAI,mBAAK,SAAQ,OAAO,QAAQ,WAAW;AAAA,EAExE;AAAA,EAEA,QAAQ,SAAwB;AAC9B,UAAM,QAAQ,WAAW,KAAK,IAAI;AAAA,EACpC;AAAA,EAEA,KAAK,SAAgC;AACnC,UAAM,KAAK,WAAW,KAAK,IAAI;AAAA,EACjC;AACF;AAxEE;AACA;AACA;AACA;AA6EF,2BACE,IACA,MACA;AACA,QAAM,UAAU,IAAI,QAAQ,IAAI;AAEhC,MAAI;AACF,UAAM,SAAS,MAAM,GAAG,OAAO;AAC/B,YAAQ,QACN,KAAK,cACD,OAAO,KAAK,gBAAgB,aAC1B,KAAK,YAAY,MAAM,IACvB,KAAK,cACP,KAAK,OACL,OAAO,KAAK,SAAS,aACnB,KAAK,KAAK,QAAQ,KAAK,IACvB,KAAK,OACP,WACN;AAAA,EACF,SAAS,QAAP;AACA,YAAQ,KACN,OAAO,KAAK,gBAAgB,aAAa,KAAK,YAAY,MAAK,IAAI,KAAK,eAAe,MACzF;AACA,UAAM;AAAA,EACR;AACF;;;AC3HA,IAAM,WAAW,CAAC,KAAK,UAAK,UAAK,UAAK,UAAK,UAAK,UAAK,QAAG;AACxD,IAAM,UAAU;AAChB,IAAM,aAAa;AAAA,EACjB,OAAO;AAAA,EACP,KAAK;AAAA,EACL,OAAO;AAAA,EACP,MAAM;AACR;AAUA,uBAAuB,UAAkB,OAAe;AACtD,MAAI,YAAY,GAAG;AACjB,WAAO,QAAQ,OAAO,KAAK;AAAA,EAC7B;AACA,MAAI,YAAY,KAAK,MAAM,QAAQ,GAAG;AACpC,WAAO,IAAI,OAAO,KAAK;AAAA,EACzB;AAEA,QAAM,aAAa,KAAK,MAAM,WAAW,KAAK;AAC9C,QAAM,iBAAkB,WAAW,QAAS;AAC5C,QAAM,YAAY,KAAK,MAAM,iBAAiB,CAAC;AAC/C,MAAI,WAAW,SAAS;AACxB,MAAI,QAAQ,aAAa,IAAI,GAAG;AAC9B,eAAW;AAAA,EACb;AAEA,QAAM,OAAO,QAAQ,OAAO,UAAU;AACtC,QAAM,QAAQ,IAAI,OAAO,QAAQ,aAAa,CAAC;AAE/C,SAAO,GAAG,OAAO,WAAW;AAC9B;AAGA,qBAAqB,UAAkB,OAAe;AACpD,SAAO;AAAA,IACL,WAAW;AAAA,IACX,WAAW,KAAK,OAAO,KAAK,MAAM,WAAY,SAAQ,EAAE,CAAC;AAAA,IACzD,WAAW,MAAM,OAAO,QAAQ,KAAK,KAAK,WAAY,SAAQ,EAAE,CAAC;AAAA,IACjE,WAAW;AAAA,EACb,EAAE,KAAK,EAAE;AACX;AAGO,IAAK,WAAL,kBAAK,cAAL;AACL,yBAAU;AACV,uBAAQ;AAFE;AAAA;AAkCZ,IAAM,iBAAiB;AAAA,EACrB,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,IACP,GAAG;AAAA,IACH,OAAO;AAAA,EACT;AAAA,EACA,OAAO;AAAA,EACP,OAAO;AACT;AAvGA;AAgHO,IAAM,WAAN,cAA8D,UAAU;AAAA,EAa7E,YAAY,SAAiC;AAC3C,UAAM;AAbR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAU;AAKR,uBAAK,QAAQ,QAAQ;AACrB,uBAAK,aAAc,QAAQ,cAAc,eAAe;AACxD,uBAAK,WAAY,QAAQ,YAAY,eAAe;AACpD,uBAAK,WAAY,QAAQ,YAAY,eAAe;AACpD,uBAAK,SAAS,QAAQ,SAAU,CAAC;AACjC,uBAAK,QAAS,QAAQ,SAAS,eAAe;AAC9C,uBAAK,QAAS,QAAQ,SAAS,eAAe;AAI9C,QAAI,QAAQ,YAAY,MAAM;AAC5B,WAAK,MAAM;AACX,yBAAK,aAAc,QAAQ,SAAS,OAAO,eAAe,QAAQ;AAClE,yBAAK,gBAAiB,QAAQ,SAAS,UAAU,eAAe,QAAQ;AACxE,yBAAK,eAAgB,QAAQ,SAAS,SAAS,eAAe,QAAQ;AAAA,IACxE,OAAO;AACL,WAAK,MAAM;AACX,yBAAK,aAAc,eAAe,QAAQ;AAC1C,yBAAK,gBAAiB;AACtB,yBAAK,eAAgB,eAAe,QAAQ;AAAA,IAC9C;AAAA,EACF;AAAA,EAGA,IAAI,MAAM,OAAuB;AAC/B,uBAAK,SAAS;AAAA,MACZ,GAAG,mBAAK;AAAA,MACR,GAAG;AAAA,IACL;AACA,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,IAAI,QAA8B;AAChC,WAAO;AAAA,MACL,GAAG,mBAAK;AAAA,MACR,OAAO,mBAAK;AAAA,MACZ,OAAO,mBAAK;AAAA,MACZ,UAAU,mBAAK,YAAW,IAAI,IAAI,mBAAK,UAAS,mBAAK;AAAA,IACvD;AAAA,EACF;AAAA,EAGA,IAAI,OAAe;AACjB,WAAO,OAAO,mBAAK,YAAU,aAAa,mBAAK,QAAL,WAAW,KAAK,SAAS,mBAAK;AAAA,EAC1E;AAAA,EAEA,IAAI,KAAK,OAAgC;AACvC,uBAAK,QAAQ;AACb,SAAK,OAAO;AAAA,EACd;AAAA,EAGA,IAAI,aAAqB;AACvB,WAAO,OAAO,mBAAK,iBAAgB,aAAa,mBAAK,aAAL,WAAiB,KAAK,SAAS,mBAAK;AAAA,EACtF;AAAA,EAEA,IAAI,WAAW,OAAgC;AAC7C,uBAAK,aAAc;AACnB,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAe;AACvB,uBAAK,QAAS;AACd,SAAK,OAAO;AAAA,EACd;AAAA,EAGA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAe;AACvB,uBAAK,QAAS;AACd,SAAK,OAAO;AAAA,EACd;AAAA,EAGA,OAAO,OAAe,OAAwB;AAC5C,uBAAK,QAAS;AACd,QAAI,OAAO;AACT,yBAAK,SAAS;AAAA,QACZ,GAAG,KAAK;AAAA,QACR,GAAG;AAAA,MACL;AAAA,IACF;AACA,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,AAAU,OAAO,KAAqB;AACpC,UAAM,WAAW,mBAAK,YAAW,IAAI,IAAI,mBAAK,UAAS,mBAAK;AAE5D,UAAM,MAAM,KAAK,IAAI,KAAK,IAAI,UAAU,CAAC,GAAG,CAAC,IAAI;AACjD,UAAM,WACJ,KAAK,IAAI,GAAG,gBAAgB,KAAK,KAAK,CAAC,CAAC,IACxC,KAAK,MAAM,GAAG,gBAAgB,KAAK,KAAK,GAAG,CAAC;AAE9C,QAAI;AACJ,QAAI,mBAAK,iBAAgB;AACvB,YAAM,QAAQ,KAAK,MAAM,MAAO,OAAO,mBAAK,aAAY,IAAI,mBAAK,gBAAe;AAChF,gBAAU,mBAAK,iBACV,oBAAK,mBAAkB,UACpB,KAAK,IAAI,GAAG,gBAAgB,KAAK,KAAK,CAAC,CAAC,IACxC,KAAK,mBAAK,mBACd,mBAAK,gBAAe,SACpB,KAAK,QACL,mBAAK,gBAAe;AAAA,IAC1B;AAEA,UAAM,SAAS,sBAAsB,mBAAK,eAAc,YAAY,gBAAgB;AAEpF,UAAM,aAAa,KAAK;AAExB,WAAO;AAAA,MACL,UAAU,UAAU,MAAM;AAAA,MAC1B,aAAa,aAAa,MAAM;AAAA,MAChC;AAAA,MACA,OAAO,UAAU,mBAAK,UAAS;AAAA,MAC/B,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP,EACG,OAAO,OAAO,EACd,KAAK,EAAE;AAAA,EACZ;AAAA,EAEA,QAAQ,SAAwB;AAC9B,UAAM,QAAQ,WAAW,KAAK,IAAI;AAAA,EACpC;AAAA,EAEA,KAAK,SAAgC;AACnC,UAAM,KAAK,WAAW,KAAK,IAAI;AAAA,EACjC;AACF;AAvJE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwJF,4BACE,IACA,MACA;AACA,QAAM,MAAM,IAAI,SAAS,IAAI;AAE7B,MAAI;AACF,UAAM,SAAS,MAAM,GAAG,GAAG;AAC3B,QAAI,QACF,KAAK,cACD,OAAO,KAAK,gBAAgB,aAC1B,KAAK,YAAY,MAAM,IACvB,KAAK,cACP,KAAK,OACL,OAAO,KAAK,SAAS,aACnB,KAAK,KAAK,IAAI,KAAK,IACnB,KAAK,OACP,WACN;AAAA,EACF,SAAS,QAAP;AACA,QAAI,KACF,OAAO,KAAK,gBAAgB,aAAa,KAAK,YAAY,MAAK,IAAI,KAAK,eAAe,MACzF;AACA,UAAM;AAAA,EACR;AACF;;;ACzRA,IAAO,cAAQ;",
  "names": []
}
